|**
----------------------------
LDON_GUILD.mac
----------------------------
This macro will request an zone start based LDON, accept it, and enter it
Proceed to complete it, and exit. Re-request.
Note: will load/unload other group members macros on enter/exit.

Requries NO Active Hacks unless stuck (warp)
Requires MQ2Nav Support
    
Usage: 
MMC:    /mac ldon_guild dgga gsay butcher TRUE TRUE
MIRA:	/mac ldon_guild dgga gsay everfrost TRUE TRUE
TAK:	/mac ldon_guild dgga gsay nro TRUE TRUE
GUK:    /mac ldon_guild dgga gsay sro TRUE TRUE
RUJ:    /mac ldon_guild dgga gsay ecommons TRUE TRUE
______________________________________________
REVISION HISTORY
    09.24.2017	xiris	INITIAL REVISION
	09.26.2017  xiris   MODIFIED to use an ini to define all mission criteria based on starting zone (butcher,everfrost,etc)
	09.30.2017  xiris   Random code clean up
	06.18.2020	xiris   Commented and cleaned up. Again.
	12.08.2021	xiris	Aligned the puller part of the macro with bot_pull updates using MQ2Nav
	12.27.2021	xiris	Changed completion routine to use Origin to go back to lobby instead of dealing with shitty trying to get to zone out
	01.19.2022	xiris	Added support for mq2doors due to takish-hiz having retarded door mechanics
						Added support to stop and ask for buffs in lobby since we run through anyway
	03.04.2022  xiris   Added support for MQ2AdvPath pathing for NRO as test for turning off mq2nav after lobby magus
						to NRO zone in.
	03.06.22	xiris	Added support for high requesting high risk missions (bln_highRisk)			
	03.28.23	xiris	Split this file from regular LDON since donor hall allows fast travel	
						Donor hall trivialized the movement to the LDON entrance, etc so culled some code	
	05.15.23	xiris   Added checks for being pushed out of navigable areas, will warp to point if there is an issue
	10.12.23	xiris	Added support for running this from guildhall in donor mode (using magus to get to thundercrest => ldon guys)
	07.29.24	xiris	Small logic changes for pull/killTarget methods
______________________________________________
REQUIRED PLUGINS
    mq2cast
    mq2eqbc
    mq2debuffs
	mq2doors
    mq2moveutils
	mq2nav
	mq2piggyzone
	mq2mmoreachit
______________________
REQUIRED INCLUDES 
	xiris_common/spell_routines.inc
	xiris_common/xiris_common.inc
**|


#include xiris_common/xiris_common.inc
|#include xiris_common/xiris_pull.inc


#TURBO 120

#define INI_ldonInfo xiris_common/xiris_ldon_definitions.ini

#EVENT Zoned                "You have entered#*#"
#EVENT Zoned                "LOADING, PLEASE WAIT..."
#EVENT NoLOS				"#*#you cannot see your target#*#"
#EVENT TooClose				"#*#your target is too close#*#"
#EVENT NavStuck				"#*#Could not find path to destination#*#"
#EVENT NavStuck 			"#*#Could not locate starting point on navmesh#*#"
#EVENT UILocked				"#*#You can't use that command right now#*#"


Sub Main(string _channel, string _announce, string _theme, bool _useDownFlags, bool _highRisk)
	/delay 5


	|-- initialize common xbot variables
	/call xbot_initialize ${Me.Name}
	
	|-- initialize variables specific to this macro
	/call variant_initialize  ${_channel} ${_announce} ${_theme} ${_useDownFlags} ${_highRisk}
	
	|-- report status
	/delay 10
	/echo \agLDON Runner \aw>> @\ao${_channel}  \aw>> \agTheme: \ao${_theme} \aw>> \agAdventure Request: \ao${adventureGiver}

	|-- Build Alert List
	/call setAlerts

	|**
	 ----------------------------
	 Setup Loop
	 ----------------------------
	 Set up the current LDON based on the start zone shortName.
	 butcher|everfrost|nro|sro|ecommons
	 ----------------------------
	**|
	:SetupLoop
		/echo Main:SetupLoop

		|-- check that the group is in zone
		/call chkGroup

		|-- request the LDON, kicking off the zoning to start logic
		|   this will move entire group into LDON instance
		|   requestLDON-> zoneLDON -> setupTask
		|-- if already in the dungeon, you probably restarted it manually since something else fucked up. Skip task requesting...
		/if (${Zone.ShortName.NotEqual[thundercrest]} && ${Zone.ShortName.NotEqual[guildhall]} && ${Zone.ShortName.NotEqual[guildlobby]}) {
			/echo \aoNot in Start Zone, maybe in adventure already?
			/call resumeLDON
		} else {
			|-- remove yourself from any adventures that might be lingering
			/echo \awKilling any previous LDON adventure that is active \ao${inMission} ${haveMission}
			/if (${Window[ConfirmationDialogbox].Open}) {
				/echo \ayConfirmationDialogbox Open
				/squelch /${cmdChannel} /notify ConfirmationDialogbox CD_Yes_Button leftmouseup
				/varset inMission 	FALSE 
				/varset haveMission FALSE
				/delay 10
			}
			| I have no LDON mission, request
			/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently assigned]}) {
				/echo \agCalling requestLDON
				/varset inMission 	FALSE 
				/varset haveMission FALSE
				/call requestLDON
			} else {
			| I had a LDON mission, killing it
				/echo \ay I had a LDON mission, killing it
				/squelch /${cmdChannel} /notify AdventureRequestWnd AdvRqst_RequestButton leftmouseup
				/varset inMission FALSE 
				/varset haveMission FALSE
				/delay 10
				/call requestLDON
			}
			
			/delay 5s
			
			
			| double check that I have one cause this fucks up now and then on this server
			/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently assigned]}) {
				/echo \arYou are not currently assigned...\ao Trying Again
				/goto :SetupLoop
			}
			/if (${haveMission}) /call zoneLDON
			/doevents
			/if (!${inMission} || !${haveMission}) /goto :SetupLoop
		}

		

	|**
	 ----------------------------
	 Mission Loop
	 ----------------------------
	 Checks Completion
	 Runs the bot_pull.mac functionality
	 ----------------------------
	**|
	
	:MissionStart	
		/echo Main:MissionStart
		|-- set up any melee buffs/delay and then go to camp inside the LDON zone;
		/call chkGroup
		/delay 5s
		/varset int_currentCamp 1
		/if (${bln_hasSHM}) {
			/docommand /${announceChannel} doShrink
			/delay 10s
		} else /if (${bln_hasBST}) {
			/docommand /${announceChannel} doShrink
			/delay 30s
		}

		/call moveCamp ${int_currentCamp}
		
	
	:MissionLoop
		/echo Main:MissionLoop
		/if (${MacroQuest.GameState.Equal[CHARSELECT]} || ${MacroQuest.GameState.Equal[PRECHARSELECT]} ) /end
		/if (${Me.Casting.ID} && ${Me.Hovering}||${Window[tradewnd].Open}||${Window[lootwnd].Open}) /goto :mainLoop
		
		/call RunAllEvents
		/doevents
		
		|-- utility checking
		/call chkUtils
		/call chkDownshits
		
		|-- reset variables, and make sure I am in the zone still and in mission
		/call setRSTVars

		|-- check that I am i n zone still
		/call chkZone
		/if (${Macro.Return.Equal[DEAD]}) {
			/dgt We seem to have gotten fucked up and are now in the lobby at ${Time.Time24}
			/dgt Resetting everything and going again
			/call OriginToGuildHall
			/call ResetAtGuildHall
			/delay 10s
			/call chkGroup
			/goto :SetupLoop
		}
		|-- check to see if I've finished the mission yet
		/if (!${inMission} || !${haveMission})  /goto :SetupLoop
		/if (${SpawnCount[NPC radius 100]} == 0 && ${Zone.ShortName.NotEqual[${str_startZone}]}) /call chkLDONCompletion	
		/if (${Zone.ShortName.Equal[${str_startZone}]} || (!${inMission} || !${haveMission})) /goto :SetupLoop
		
		|-- reset group to camp spot (leash) if its empty
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 25]} == 0) {
			/call resetCamp
			/call RefreshXTarget
			/docommand /${cmdChannel} Disengage
			/if (${bln_looting})	/call chkLoot
			/if (!${bln_looting})	/hidecorpse npc
			/if (${Me.Class.ShortName.Equal[SHD]} && ${Me.PctMana} < 10) {
				/echo OUT OF MANA
				/delay 10
				/goto :MissionLoop
			}
		}
		
		|-- UI lock check
		/if (${bln_UILocked}) {
			/echo \arUI Locked!\agZoning to clear
			/call clearUILock
		}

		|-- target hunter
		:getAndKill
			/attack off
			/call chkLDONCompletion
			/call getTarget
			/if (${Target.Distance} > 20) /call pullTarget
			/if (!${Target.ID}) /goto :getAndKill
			/call killTarget
			/echo We have killed ${int_killCount} mobs

		|-- am I still in mission?
		/if (${inMission}) /goto :MissionLoop

	
	|-- adventure is over, start the setup of another, ad infinitem!
	/goto :SetupLoop

/return


Sub resumeLDON
	/call setupTask
	/call setGroupCommands
	/call setEntranceVars
	/varset str_startZone thundercrest
	/varset haveMission TRUE
	/varset inMission   TRUE
	/varset ldonType Mob Count
/return

Sub requestLDON
	/echo \aorequestLDON \ag:inMission\ao${inMission}  \ag:haveMission\ao${haveMission}
	/if (${inMission})   /return
	/if (${haveMission}) /return
	/echo \awrequestLDON in zone \ao${zoneRequest} \awcurrently in: \ao${Zone.ShortName}
	|-- this is anachronistic if we are phasing out piggyzon
	:ThundercrestStart
	/if (${Zone.ShortName.NotEqual[thundercrest]}) {
		/if (${Zone.ShortName.Equal[guildhall]}) {
			/echo \aoIn guildhall, moving to \awThundercrest
			/call zoneByMagus thundercrest
			/goto :ThundercrestStart
		} else {
			/echo \arI don't know where we are!
			/echo Not in Thundercrest, not sure why. Ending
			/end
		}
	} 
	
	/echo \agIn Thundercrest

	/declare requestCount int local 1
	
	|-- Get Adventure Loop, request the adventure from the giver.
	:GetAdventure
		/echo \a-w        Getting adventure from ${adventureGiver} ${Time.Time24}
		/call TrueTarget ${Spawn[npc ${adventureGiver}].ID}
		/echo \a-w        Path to \ag${adventureGiver}\aw? \ag${Navigation.PathExists[spawn ${adventureGiver}]}
		| Navigate to Adventurer
		/if (${Navigation.PathExists[spawn ${adventureGiver}]}) {
			/docommand /${cmdChannel} /navigate spawn ${adventureGiver}
			/delay 80
		} else {
			/docommand /${cmdChannelExcludingMe} /target id ${Spawn[npc ${adventureGiver}].ID}
			/docommand /${cmdChannel} /warp target
		}
		
		:GetAdventureNavLoop
			/echo \a-w        Navigating to \ag${adventureGiver}
			/if (${Navigation.Active}) {
				/delay 20
				/goto :GetAdventureNavLoop
			} 

		/delay 20

		:GetAdventureClick
			/echo \a-w        Requesting Adventure
			/face fast
			/delay 10
			/click right target
			/delay 20
			/click right target

	|-- set the difficulty to Hard (defaulted to no)
	/if (${bln_highRisk}) {
		/echo \a-w        Requesting a High Risk Mission
		/notify AdventureRequestWnd AdvRqst_RiskCombobox listselect ${Window[AdventureRequestWnd].Child[AdvRqst_RiskCombobox].List[High]}
	} 

	|-- set the type to Kill examples: Note EqTitan code fix as of 1/1/22 allows for chain requesting missions
	|   The only mission that will be required is the mob count since its the default.
	|  ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Single Boss]}
	|  ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Mob count]}


	/delay 10
	/call setCamp
		
	/varset ldonType NOAVAIL
	|-- First choice: Mob Count, see if this mission is available
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Mob count]} > 0) {
		/notify AdventureRequestWnd AdvRqst_typeCombobox listselect ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Mob count]} 
		/delay 10
		/notify AdventureRequestWnd AdvRqst_RequestButton leftmouseup
		/delay 2s
		/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[The number of adventures returned was zero]}) {
			/echo \a-w        Adventure type: "Mob Count" unavailable.
		} else {
			/echo \a-w        Adventure type: "Mob Count" accepted.
			/varset ldonType Mob Count
			/goto :Accept
		}
	}
	
	/if (${zoneRequest.Equal[sro]}) {
		/echo \a-w        GUK LDON can only do the kill count, since GukA for boss mob is un-navigable
		/goto :TryAgain
	}
	
	|-- have to close window and try again now apparently. 
	:GetAdventure2
		/keypress esc
		/keypress esc
		/keypress esc
		
		/echo Getting adventure2 from ${adventureGiver} ${Time.Time24}
		/call TrueTarget ${Spawn[NPC ${adventureGiver}].ID}
		/face fast
		/click right target
		/delay 2s
	
	|-- Second choice: Single Boss, see if this mission is available
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Single Boss]} > 0) {
		/notify AdventureRequestWnd AdvRqst_typeCombobox listselect ${Window[AdventureRequestWnd].Child[AdvRqst_typeCombobox].List[Single Boss]} 
		/delay 10
		/notify AdventureRequestWnd AdvRqst_RequestButton leftmouseup
		/delay 2s
		/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[The number of adventures returned was zero]}) {
			/echo \a-w        Adventure type: "Single Boss" unavailable.
		} else {
			/echo \a-w        Adventure type: "Single Boss" accepted.
			/varset ldonType Single Boss
			/goto :Accept
		}
	}
	/delay 2s


	
	/echo ldonType: ${ldonType}
	|-- No satisfactory type is available, go back to :GetAdventure
	/if (${ldonType.Equal[NOAVAIL]} || ${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently assigned]}) {
		:TryAgain
		/echo (${requestCount}) No satisafactory Adventure type available, delaying for 1m. ${Time.Time24}
		/delay 1m
		/varcalc requestCount ${requestCount}+1
		/goto :GetAdventure
	}
	
	|-- Found one, Accept the mission and start the zoning loop.
	:Accept
		/delay 10
		|-- Set the variables that define which zone we are headed to.
		|   note we no longer need to do this since donor hall handles this crap
		|/call setEntranceVars
		
		|-- Accept the task
		/notify AdventureRequestWnd AdvRqst_AcceptButton leftmouseup
		/varset haveMission TRUE
		/delay 3s
/return

Sub setEntranceVars

	|-- determine the entrance for the mission you received
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[unearthed grave in Lesser Faydark]}) /varset ldonEntrance unearthed_grave
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[crypt in Lesser Faydark]}) /varset ldonEntrance crypt
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[glimmering portal]}) /varset ldonEntrance glimmering
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[snowy mine]}) /varset ldonEntrance snowy_mine
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[quicksand pit]}) /varset ldonEntrance quicksand_pit
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[through a cave in Southern Ro]}) /varset ldonEntrance sro_cave
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[through a barricaded door in Upper Guk]}) /varset ldonEntrance barricaded_door
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[through a rotting tree trunk in Innothule]}) /varset ldonEntrance rotting_tree
	
	/echo setting ${ldonEntrance} 
	
	|-- pull information determined by entrance from INI file (waypoint, doortarget and starting zone)
	/varset wpIN  ${Ini[INI_ldonInfo,${ldonEntrance},wpIN]}
	/varset dtIN  ${Ini[INI_ldonInfo,${ldonEntrance},dtIN]}
	/varset zoneStart ${Ini[INI_ldonInfo,${ldonEntrance},zoneStart]}
	/echo setting ${ldonEntrance} entrance vars --> ${zoneStart} ${wpIN} ${dtIN}
	

/return


|**
 ----------------------------
 zoneLDON
 ----------------------------
 Zones everyone to the LDON start zone, and once in the start zone
 runs everyone to the LDON zone entrance, and clicks the door
 ----------------------------
**|
Sub zoneLDON
	/declare waitForAllInLDON int local 0
	| So much easier with Donor Hall insta porting
	/call TrueTarget ${Spawn[npc ${adventureGiver}].ID}
	/delay 60
	/say Ready
	/delay 100
	|-- loop to wait for everyone to zone in
	:ZoneIntoLDONInstanceWait
		/varcalc waitForAllInLDON ${waitForAllInLDON}+1
		/echo \a-w        Waiting for all to zone into LDON
		/delay 100

		/if (${waitForAllInLDON} > 12) /call killMacro "Group failed to zone into at ${wpIN}"
		/if (${Group.AnyoneMissing})  /goto :ZoneIntoLDONInstanceWait 
		

	
	|-- Setup the task with INI Data
	/varset inMission TRUE	
	/echo \ag		DONE \awwith zoneLDON
	/call setupTask
/return

Sub killMacro(reason)
	/echo Something failed [${reason}] at ${Time.Time24}
	/docommand /${cmdChannel} /end
/return

|**
 ----------------------------
 setupTask
 ----------------------------
 Sets up the mission parameters once inside the LDON mission zone
 ----------------------------
**|

Sub setupTask
	/echo \aoSetupTask inMission:\ag${inMission} \aohaveMission:\ag${haveMission} \agzoneMission:\ag${Zone.ShortName}
	
	/varset zoneMission ${Zone.ShortName}
	
	|-- pulling zone data from INI
	/varset dtOUT 			${Ini[INI_ldonInfo,${zoneMission},dtOUT]}
	/varset killTarget 		${Ini[INI_ldonInfo,${zoneMission},killTarget,NULL]}
	/varset int_campCount	${Ini[INI_ldonInfo,${zoneMission},campCount,6]}
	/varset int_maxRadius	${Ini[INI_ldonInfo,${zoneMission},pullDist,350]}
	/varset int_xOUT		${Ini[INI_ldonInfo,${zoneMission},xOUT,0]}
	/varset int_yOUT		${Ini[INI_ldonInfo,${zoneMission},yOUT,0]}
	/varset int_zOUT		${Ini[INI_ldonInfo,${zoneMission},zOUT,${Me.Z}]}
	|-- If we are killboss type mission we need to add killboss to list 2
	/if (${killTarget.NotEqual[NULL]}) /squelch /alert add 2 npc ${killTarget}
	
	/echo \a-w------------
	/echo \aoSetting \ag${zoneMission} \aozone vars:
	/echo 	\awdtOUT: \ag${dtOUT}\aw, killTarget: \ag${killTarget}\aw, int_campCount \ag${int_campCount}
	/echo 	\awint_maxRadius: \ag${int_maxRadius}\aw, int_xOUT: \ag${int_xOUT}\aw, int_yOUT: \ag${int_yOUT}\aw, int_zOUT: \ag${int_zOUT}
	/echo \a-w------------
	/delay 10
	|-- Turn off the fucking doors
	/docommand /${cmdChannel} /toggledoors on
	
	|-- Tell rest of group to load their normal macroset;
	/echo In ${Zone.Name}, setting up xiris_bot and delaying 5s
	/docommand /${cmdChannelExcludingMe} /mac xiris_bot ${Me.Name} Mluian NULL 60
	
	/delay 5s
	|-- set up group variables, change here based on group makeup;
	/call setGroupCommands

/return


Sub zoneByMagus(string _zoneToRequest) 
	/g Using Magus to zone ${_zoneToRequest}
	/docommand /${cmdChannel}  /tar npc magus
	/delay 10
	/docommand /${cmdChannel}  /nav target
	:magusNavWait
	/delay 10
	/if (${Nav.Active}) /goto :magusNavWait


	/delay 5s
	|-- open up the magus's merchant window which fixes the rando desynch
	/docommand /${cmdChannel} /click right target
	/delay 10
	/docommand /${cmdChannel} /keypress esc
	/delay 10
	/docommand /${cmdChannel} /tar npc magus
	/delay 10
	/docommand /${cmdChannel} /say ${_zoneToRequest}

	:magusZoneWait
	/echo \a-w        Waiting to be in ${_zoneToRequest}
	/if (!${Zone.ShortName.NotEqual[${_zoneToRequest}]}) {
		/delay 40
		/goto :magusZoneWait
	}
	/delay 45s

/return 

Sub MoveToBindFromOrigin
	/docommand /${cmdChannel} /toggledoors on
	/docommand /${cmdChannel} /nav spawn trans
	
	:translocate_rund
		/delay 20
		/if (${Navigation.Active}) /goto :translocate_run

	/delay 5s
	:translocate_ask
		/docommand /${cmdChannel} /tar trans
		/delay 5s
		/say East. Always... into the East.
		/delay 30s

/return

Sub RequestRessurection
	/docommand /${cmdChannel} /nav spawn utility
	:summoner_run
		/delay 20
		/if (${Navigation.Active}) /goto :summoner_run

	:summoner_ask
		/tar utility
		/delay 10
		/hail
		/say summon
		/delay 50
		/tar utility 
		/delay 50
		/say resurrect
		/echo \aoRequested Resurrection \awDelaying:\ag45s
		/delay 45s
/return 

Sub RequestRaidBuffs
	/g Requesting Raid Buffs
	/docommand /${cmdChannel} /toggledoors on
	/docommand /${cmdChannel} /nav wp magus

	:raid_run
		/delay 20
		/if (${Navigation.Active}) /goto :raid_run

	:raid_ask
		/dgt docharbuffs ${Me.Name}
		/delay 30s
/return


Sub RequestLobbyBuffs
	/g Requesting Lobby Buffs

	|-- Phanti Buffs
	:phanti_tar
		/docommand /${cmdChannel} /tar npc phanti
		/docommand /${cmdChannel} /nav target
	:phanti_run
		/delay 20
		/if (${Navigation.Active}) /goto :phanti_run
	:phanti_ask
		/delay 20
		/docommand /${cmdChannel} /say haste
		/delay 10
		/docommand /${cmdChannel} /say kei
		/delay 20
	
	|-- Firiona Vie Buffs
	:firi_tar
		/docommand /${cmdChannel} /tar npc firi
		/docommand /${cmdChannel} /nav target
	:firi_run
		/delay 20
		/if (${Navigation.Active}) /goto :firi_run
	:firi_ask
		/delay 20
		/docommand /${cmdChannel} /say virtue
		/delay 20

	|-- Fuzzy Buffs
	:fuzzy_tar
		/docommand /${cmdChannel} /tar npc fuzzy
		/docommand /${cmdChannel} /nav target
	:fuzzy_run
		/delay 20
		/if (${Navigation.Active}) /goto :fuzzy_run
	:fuzzy_ask
		/delay 20
		/docommand /${cmdChannel} /say ds
		/delay 10
		/docommand /${cmdChannel} /say regen
		/delay 20
	
	|-- Run to Magus
	:magus_tar
		/docommand /${cmdChannel} /tar npc magus
		/docommand /${cmdChannel} /nav target
	:magus_run
		/delay 20
		/if (${Navigation.Active}) /goto :magus_run
	
/return



Sub OriginToGuildHall
	/declare originAttempt int local 0
	/declare i int local 1
	
	:OriginDelay
	/if (${Me.AltAbilityTimer[Origin]} == 0) {
		:OriginAttempt
		/if (${Zone.ShortName.NotEqual[${Me.BoundLocation[0]}]}) {
			/varcalc originAttempt ${originAttempt} + 1
			|-- tell each group member that isn't a bard to cast origin, bard add origin to queue
			/for i 0 to ${Group}
				/if (${Group.Member[${i}].Class.ShortName.Equal[BRD]}) 	  /dex ${Group.Member[${i}]} /casting "Origin" alt
				/if (${Group.Member[${i}].Class.ShortName.NotEqual[BRD]}) /dex ${Group.Member[${i}]} /casting "Origin" alt
			/next i
			/casting origin alt
			/delay 60s
			/goto :OriginAttempt
		} else {
			/return
		}
	} else {
		/echo Origin not Ready, delaying 1m  ${Time.Time24}
		/delay 1m
		/goto :OriginDelay
	}

/return 

Sub ResetAtGuildHall
	/if (${Zone.ShortName.Equal[${Me.BoundLocation[0]}]}) {
		|/call MoveToBindFromOrigin
		/call RequestRessurection
		/call RequestRaidBuffs
		|/call RequestLobbyBuffs
		|/call zoneByMagus ${zoneMagus}
	} else {
		/g Not at guildhall, can't reset here, something went wrong at ${Time.Time24}
		/return
	}
/return

Sub setCamp
	/echo Setting camp at camp${int_currentCamp} out of ${int_campCount}

	/varset D1X ${Me.X}
	/varset D1Y ${Me.Y}
	/varset D1Z ${Me.Z}

	/delay 1s
/return

|-- Moves the current camp to n+1
|   If we cannot navigate (probably in a wall or geometry)
|   We will warp back to the current camp and then continue.
Sub moveCamp(int _campNumber) 
	/declare prevCamp int local 1
	/varcalc prevCamp ${_campNumber}-1
	/echo \aoMoving to Camp \ag${_campNumber}
	:moveCampNavLoop
	/if (${Navigation.PathExists[wp camp${_campNumber}]}) {
		/nav wp camp${_campNumber}
		/delay 5s
		/docommand /${cmdChannel} /nav wp camp${_campNumber}
		/delay 60s !${Navigation.Active}
	} else {
		/call clearNavStuck
	}
	:moveCampNavLoop
	/if (${Navigation.Active}) /goto :moveCampNavLoop

	:resume
	/call setCamp
/return



|**
 ----------------------------
 getTarget
 ----------------------------
 Checks to see if there are any mobs within camp, if so, it targets them indiscriminately
 otherwise, it attempts to target a NPC that does not fall in the alert list
 Calls chkTargetValid once a target has been found, if that returns as valid, it continues
 ----------------------------
**|
Sub getTarget
	/echo getTarget
	/if (${Me.Sitting}) /sit off
	/if (${Zone.ShortName.Equal[${Me.BoundLocation[0]}]}) /return
	:acquireLoop
		/call setRSTVars
		/squelch /target clear

		/if (!${inMission} || !${haveMission}) /return
		|----------USE THIS FOR HUNTER (ALERT 2) and IGNORE ALERT 1, 3 --------
		/if (${SpawnCount[npc radius ${int_campRadius} zradius 25]} > 0) {
			/echo NPC in camp, killing
			/target npc range ${int_minTLevel} ${int_maxTLevel} radius ${int_maxRadius} noalert 1
			/delay 5
		} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel}]} > 0) {
			/echo NPC on alert 2 is up, killing
			/target npc alert 2
			/delay 5
		} else /if (${SpawnCount[npc alert 2 radius ${int_alert2Radius} range ${int_minTLevel} ${int_maxTLevel}]} == 0 && ${SpawnCount[npc noalert 1]} > 0) {
			/echo No NPCs on the alert 2 list are up, trying random NPC
			/target npc range ${int_minTLevel} ${int_maxTLevel} radius ${int_maxRadius} noalert 1 
			/delay 5
		}
		
		/if (${Target.ID} && (${Target.Distance} <= ${int_campRadius})) {
			|--if it is close, its valid;
			/varset bln_validTGT	TRUE
		} else {
			|--check the target
			/if (${Target.ID}) /call chkTargetValid
		}
		
		
		|--restart
		/if (!${bln_validTGT}) {
			|-- if there is more than 1 camp in our dataset, we can start walking through the camps
			/if (${int_campCount} > 1) {
					/echo Checking on moving the camp
					:MoveCamp
					/if (${int_currentCamp} < ${int_campCount}) {
						/varcalc int_currentCamp ${int_currentCamp} + 1
					} else {
						/varcalc int_currentCamp ${int_currentCamp} - 1
					}
					
					/echo Moving Camp to ${int_currentCamp}
					/call moveCamp ${int_currentCamp}
					/delay 10
			} else {
				/echo no valid target delaying 5s
				/delay 5s
			}
			/goto :acquireLoop
		}
		|--target is valid, continue
		
		/varset int_targetID ${Target.ID}
		/varset bln_TGTDead		FALSE
		/varset int_distTGT ${Int[${Target.Distance}]}
		/echo \awAcquired \ag${Target.Name} \awat range \ag${Int[${Target.Distance}]} \awkilled: (\ag${int_killCount}\aw)
/return

|**
 ----------------------------
 chkTargetValid
 ----------------------------
 Checks to see if the current target passes the criteria
 If it is a valid target, bln_validTGT is assigned TRUE
 Returns to getTarget
 ----------------------------
**|
Sub chkTargetValid
	/echo chkTargetValid ${Target.Name}
	/if (${Target.Type.NotEqual[NPC]}) /return

	|--check to see if its a corpse
	/if (${Target.Name.Find['s_corpse]}) {
		/echo \arINVALID \awTarget is a corpse!
		/call setTGTAlert
		/return
	}
	
	|--check if there is a path to the target
	/if (!${Navigation.PathExists[target]}) {
		/echo \arINVALID \awNo Path to Target
		/call setTGTAlert
		/return
	}
	
	|--check my target is the apropriate level
	/if ((${Target.ID}) && (${Target.Level} < ${int_minTLevel})) {
		/echo \arINVALID \awTarget too low of a level
		/call setTGTAlert
		/return
	}
	/if (${Target.Underwater}) {
		/echo \arINVALID \awTarget is underwater
		/call setTGTAlert
		/return
	}
	
	|--check my target is the above the apropriate z-radius floor
	/if ((${Target.ID}) && ${Int[${Target.Z}]}<${int_minZHeight}) { 
		/echo \arINVALID \awTarget below z floor
		/call setTGTAlert
		/return
	} 
	|--check my target is the above the apropriate z-radius ceiling
	/if ((${Target.ID}) &&${Int[${Target.Z}]}>${int_maxZHeight}) { 
		/echo \arINVALID \awTarget below z ceiling
		/call setTGTAlert
		/return
	}
	
	/varset bln_validTGT	TRUE
/return 	




|**
 ----------------------------
 pullTarget
 ----------------------------
 Checks to see if we need to pull target, if so, then we initiate the pulling mechanism
 and then once aggro is established, drags the mob back to camp to be killed
 Calls AggroTarget
 Calls makecamp return
 Returns to mainLoop if a valid pull has been achieved
 ----------------------------
**|
Sub pullTarget
	/echo pullTarget ${bln_validTGT}
	/declare campDist 	int local
	/declare dist 		int local
	|--check to see if we have a valid target, or skip
	/declare attempt 	int local 0
	

	
	:pullLoop
		/if (!${bln_validTGT}) 					/goto :return
		/if (!${Target.ID}) 					/goto :return
		/if (${Target.Type.NotEqual[NPC]}) 		/goto :return
		/if (${Target.Name.Find['s_corpse]})	/goto :return

		| Start the pull by running to the target
		:RunningToTarget
		/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) 	/goto :ReturnWithPull
		/if (${Navigation.PathExists[target]}) {
			/if (!${Navigation.Active}) {
					/navigate target
					/echo \agRunningToTarget
					/delay 15
				} else /if (${Navigation.Velocity} < 20) {
					/echo \arPontentially Stuck
					/warp id ${Me.ID} f 10
				}
		} else {
			/call clearNavStuck
			/goto :RunningToTarget
		}

		| Target has me as aggrod, and in range, going to returnWithPull
		/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]} && (${Target.Distance3D} < ${int_castDistance})) {
			/echo \a-w        Target has me as aggrod, and in range, going to returnWithPull
			/goto :ReturnWithPull
		} 

		| Too many attempts, returnwithpull
		/if (${attempt} > 10) {
			/echo \a-w        Too many attempts, returnwithpull
			/alert add 1 "${Target.ID}"
			/target clear
			/goto :ReturnWithPull
		} 

		| Target in LOS, and in distance, going to aggrocheck
		/if (${Target.LineOfSight} && ${Target.Distance3D} < ${int_castDistance}) {
			/echo \a-w        Target in LOS, and in distance, going to aggrocheck
			/goto :AggroCheck
		}

	
		/if (!${Target.ID}) /goto :return

		|-- check to see if I have aggro
		:AggroCheck
		/if (!${Me.TargetOfTarget.ID} && ((${Me.XTarget} <= ${int_maxPullCount}))) {
			:AggroDistCheck 
			| Am I close enough to aggro?
			/if (${Target.Distance3D} > 200) /goto :RunningToTarget

			/if ((${Target.Distance} < ${int_castDistance}) && ${Target.LineOfSight}) {
				| I am close enough, call aggro sub.
				/echo \ao Attempting to Aggro Target
				/call AggroTarget
				/varcalc attempt ${attempt} + 1
				/echo \aoAggro Attempt return ${Macro.Return}
				/if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) 	/goto :ReturnWithPull
				/if (${Macro.Return.Equal[FAILED]})					/goto :AggroCheck
				/if (${Macro.Return.Equal[NOLOS]})    				/goto :RunningToTarget
				/if (${Macro.Return.Equal[CAST_FIZZLE]})    		/goto :AggroCheck
				/if (${Macro.Return.Equal[NOTARGET]}) 				/goto :return
				/if (${Macro.Return.Equal[NOMANA]})					/goto :RunningToTarget
				/if (${Macro.Return.Equal[SUCCESS]})  {
					/doevents NoLoS 
					/if (${bln_noLOS}) {
						/varset bln_noLOS FALSE
						/goto :RunningToTarget
					} else {
						/goto :ReturnWithPull 
					}
				}
			} else { 
				/goto :RunningToTarget
			}
		} else {
			| I have aggro, returning to camp
			:ReturnWithPull
				/echo \agReturning to Camp with \ay${Me.XTarget}+ \agmobs.
				/if (${Navigation.PathExists[waypoint camp${int_currentCamp} ]}) {
					/navigate waypoint camp${int_currentCamp} 
				} else {
					/call clearNavStuck
				}
				/goto :ReturnLoop
			
			:ReturnLoop
				/delay 10
				/varcalc dist ${Math.Distance[${Me.Y},${Me.X},${Me.Z}:${D1Y},${D1X},${D1Z}]}
				/if (${dist} < ${pulltocamp}) /nav stop
				/if (${Navigation.Active})  /goto :ReturnLoop
		}
	:return
/return	
	

Sub AggroTarget 
	/if (${Navigation.Active}) /navigate stop
	/declare ret string local FAILED
	:TargetAggroCheck
	/if (!${Target.ID}) {
		/varset ret NOTARGET
	} else /if (!${Target.LineOfSight}) {
		/varset ret NOLOS
	} else /if (${Me.TargetOfTarget.Name.Equal[${Me.Name}]}) {
		/varset ret SUCCESS
	} else {
		| Need to aggro the mob somehow
		:AttemptAggro
		/if (${strPullType.Equal[RANGED]}) {
			/face fast
			/delay 5
			/ranged
			/doevents TooClose
			|-- Sometimes if we aren't spell casting and using range weapons we might be too close, and cannot hit them with it.
			/if (${bln_tooClose}) {
				/echo Too Close! Handling
				/if (${Me.Class.ShortName.Equal[PAL]}) /call MQ2Cast "${spell_pull}" ${spell_pullGem} 2s
				/if (${Me.Class.ShortName.Equal[WAR]}) /call chk_warProvoke "${war_ca_hate_1}"
				/delay 1
				/if (${Me.AbilityReady[Taunt]}) /doability Taunt
				/varset bln_tooClose FALSE
				/goto :TargetAggroCheck
			}
			/delay 10
			/goto :TargetAggroCheck
		} else {
			/if (${Me.PctMana} > 10) {
				/call chkSpellMemorized "${spell_pull}" TRUE ${spell_pullGem}
				/echo \awReady?\ag${Me.SpellReady[${spell_pull}]} \awCasting \ag"${spell_pull}" \ap${spell_pullGem} \aw2s
				/call MQ2Cast "${spell_pull}" ${spell_pullGem} 2s
				/doevents NoLOS
			
				/if (${bln_noLOS}) /varset ret NOLOS
				/if (${Macro.Return.Equal[CAST_SUCCESS]}) /varset ret SUCCESS
				/if (${Macro.Return.Equal[CAST_CANNOTSEE]}) /varset ret NOLOS
				/if (${Macro.Return.Equal[CAST_INTERRUPTED]}) /goto :AttemptAggro
	
				
			} else {
				/varset ret NOMANA
			}
		} 
	}
	:return
/return ${ret}
	
|**
 ----------------------------
 Wait for the mob to be within kill/stick range, then issue
 /attack on command to mq2melee
 Calls chkCombatState while in the combatLoop
 ----------------------------
**|
Sub killTarget
	/echo \agKillTarget \ay ${Time.Time24}
	/if (${Zone.ShortName.Equal[${zoneRequest}]}) /return
	/if (!${Target.ID} || ${Target.Type.Equal[PC]}) /return
	/if (!${bln_validTGT}) /return
	/if (${bln_TGTDead})   /return
	/if (${Navigation.Active}) /navigate stop
	
	/declare int_waited int local 0
	|--check camp distance
	:campCheck
	/if (${Math.Distance[${Me.Y},${Me.X}:${D1Y},${D1X}]} > ${int_campRadius}) {
		/if (!${Navigation.Active}) /navigate waypoint camp${int_currentCamp}
		/echo \agMoving back to \aocamp${int_currentCamp}
		/delay 20
		/goto :campCheck
	} else {
		/if (${Navigation.Active}) /navigate stop
	}

	|--check the distance, if its out of melee range/aggro range, lets wait a second
	/face fast

	:distanceWaitLoop
		/varcalc int_waited ${int_waited}+1
		/if (${int_waited} > 15) /return
		/if (!${Target.ID}) 	 /return
		/delay 5
		/if (${Target.Distance} > ${int_campRadius}) {
			/if (${SpawnCount[npc radius ${int_campRadius} range ${int_minTLevel} ${int_maxTLevel}]} > 0) {
				/echo Something already in camp, changing target
				/target npc radius ${int_campRadius} range ${int_minTLevel} ${int_maxTLevel}
				/varset int_targetID ${Target.ID}
				/delay 5
				/varset bln_validTGT	TRUE
				/goto :killMob
			} else {
				/echo  Distance not covered! ${Target.Distance}::${int_waited} ${Target.Distance} > ${int_campRadius}
				/delay 20 ${Target.Distance} < ${int_campRadius}
				/goto :distanceWaitLoop
			}
		}
		
	:killMob
	/echo \aoIssuing Kill Command
	|--issue kill command
	/docommand /${announceChannel} KillMob ${Target.ID} "${Target.Name}" ${Time.Time24}
	/call ResetCastTimers
	/face fast
	/attack on

	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && (${Me.Class.ShortName.Equal[SHD]}) && ${Me.SpellReady[${spell_aehate}]} ) {
		/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
		/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
	}
	
	/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.CombatAbilityReady[Area Taunt]}) {
		/doability "Area Taunt"
	} else /if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[WAR]} && ${Me.AltAbilityReady[Rampage]}) {
		/call MQ2Cast "Rampage" alt
	}
	
	
	|--while in combat do these things
	:combatLoop
		/call chkCombatState
		/if (${int_targetID} != ${Target.ID}) 			/goto :return
		/if (${Target.Type.NotEqual[NPC]}) 				/goto :return
		/if (${Target.Distance} > ${int_campRadius}) 	/goto :distanceWaitLoop 

		/if (${Me.Class.ShortName.Equal[PAL]}) {
			/call chkHeal_Self
			/call chkHeal_Group
		}

		/if (${Me.Class.ShortName.Equal[SHD]}) {
			/call chkCA_${Me.Class.ShortName}
			/if (${bln_lifetapUse} && (${Me.PctHPs} <= ${int_lifetapHP}))	/call chkLifetap
		}


		/if (!${bln_TGTDead}) {
			/if ((${Me.TargetOfTarget.ID} != ${Me.ID}) && !${Target.Fleeing}) {
				/if ((${Me.Class.ShortName.Equal[SHD]} || ${Me.Class.ShortName.Equal[PAL]}) && ${Me.SpellReady[${spell_hate}]}) {
					/call MQ2Cast "${spell_hate}" ${spell_hateGem}
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_1}]})) {
					/doability "${war_ca_hate_1}"
				} else /if (${Me.Class.ShortName.Equal[WAR]} && (${Me.CombatAbilityReady[${war_ca_hate_2}]})) {
					/doability "${war_ca_hate_2}"
				} 
			} 
			/if ((${SpawnCount[npc radius ${int_campRadius}]} > 1) && ${Me.Class.ShortName.Equal[SHD]}  && ${Me.SpellReady[${spell_aehate}]} ) {
				/echo ${Me.SpellReady[${spell_aehate}]} Cast ${spell_aehate} ${spell_aehateGem} 5s
				/call MQ2Cast "${spell_aehate}" ${spell_aehateGem}
			}
			/goto :combatLoop
		} else {
			/echo \agTarget is dead, return
		}
	:return	
	/hidecorpse npc
/return

Sub chkLDONCompletion
	/echo \archkLDONCompletion for \ag${ldonType} ${int_killCount}\aw dead \aw(\ao${int_totalKills}\aw)
	|-- Make sure the Adventure window is open
	/if (!${Window[AdventureRequestWnd].Open}) {
		/keypress alt+v
		/delay 1s
	}

	|-- Check if the Adventure is complete
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[You are not currently]} > 0) /varset missionComplete TRUE
	/if (${Window[AdventureRequestWnd].Child[AdvRqst_NPCText].Text.Find[The wicked immortals]} > 0)  /varset missionComplete TRUE
	
	/if (${SpawnCount[npc radius 100 noalert 1]} > 0) /return
	
	| Requires zoning back to ${zoneRequest}
	/if (${missionComplete}) {
		/echo Mission has been completed leaving zone
		/declare i int local 1
		/declare originAttempt int local 0
		/declare zoneRequestAttempt int local 0
		
		/echo Mission has been completed zoning back to base zone ${zoneRequest} delaying 45s to finish looting etc
		|-- kill all group member macros, end melee, and twisting
		/delay 45s
		/squelch /docommand /${cmdChannelExcludingMe}  /medley stop
		/squelch /docommand /${cmdChannelExcludingMe}  /end
		/docommand /${cmdChannel} /keypress esc
		/docommand /${cmdChannel} /keypress esc
		/delay 10
		/docommand /${cmdChannel} /stand on
		/docommand /${cmdChannel} /nav stop
		/delay 15s
		
		/varset missionComplete TRUE
		/docommand /${cmdChannel} /keypress esc
		/docommand /${cmdChannel} /keypress esc
		
		
		|-- return to guild lobby
		/g Returning to Thundercrest ${Time.Time24} Origin Ready: ${Me.AltAbilityReady[Origin]}
		/call OriginToGuildHall
		/call ResetAtGuildHall
		
		|-- Reset Adventure variables now that we are complete

		/g ${Time.Time24} Mission Complete, resetting variables, and starting this over again ${Time.Time24}
		/varset inMission 		FALSE
		/varset haveMission 	FALSE
		/varset missionComplete FALSE
		/varset int_killCount 		0

	}
	
/return


|**
 ----------------------------
 chkCombatState
 ----------------------------
 A determination call, to see if current target is dead, or otherwise not
 a valid target anymore
 ----------------------------
**|
Sub chkCombatState
	/if (${Target.Type.NotEqual[NPC]}) 		 /varset bln_TGTDead TRUE
	/if (${Target.Type.Equal[Item]})		 /varset bln_TGTDead TRUE
	/if (!${Target.ID}) 					 /varset bln_TGTDead TRUE
	|/if (${bln_TGTDead} && ${SpawnCount[npc radius ${int_campRadius}]} == 0 && ${bln_looting}) /call chkLoot
/return

|**
 ----------------------------
 chkUtils
 ----------------------------
 Here we check mana of the cleric & the puller
 Here we check the endurance of the puller
 Here we check the hitpoints of the puller

 ----------------------------
**|

Sub chkUtils
	/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
	/varset bln_wait4Mana	FALSE
	/varset	bln_wait4End	FALSE
	/varset bln_wait4HP		FALSE

	/echo chkUtils

	:chkUtilLoop
		/call chkMana
		/call chkEndurance
		/call chkHP
		/if (${strPullType.NotEqual[SPELL]}) {
			| ${component} ${count} ${compType} ${summoner} ${reagent}
			/call chkComponentsAll
		}
		/if (${bln_wait4Mana} || ${bln_wait4End} || ${bln_wait4HP}) {
			/echo Waiting for : mana: ${bln_wait4Mana} endurance: ${bln_wait4End} hitpoints: ${bln_wait4HP}
			/if (${SpawnCount[npc radius ${int_campRadius}]} > 0) /return
			/if (!${Me.Sitting}) /sit on 
			/delay 5s
			/goto :chkUtilLoop
		}
		/if (${Me.Sitting}) /sit off
/return

Sub chkMana
	/varset bln_wait4Mana FALSE
	/if ((${bln_hasCLR} && ${Group.Member[${str_cleric}].Present}) && (${Group.Member[${str_cleric}].PctMana} < ${int_clrManaFloor})) {
		/echo Cleric mana ${Group.Member[${str_cleric}].PctMana} < ${int_clrManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	
	/if (${strPullType.Equal[SPELL]} && (${Me.PctMana} <  ${int_myManaFloor})) {
		/echo  ${strPullType} My mana ${Me.PctMana} < ${int_myManaFloor}
		/varset bln_wait4Mana TRUE
	}
	
	
/return


Sub chkEndurance
	/varset bln_wait4End FALSE
	/if (${Me.PctEndurance} < ${int_myEnduranceFloor}) 	/varset bln_wait4End TRUE
/return

Sub chkHP
	/varset bln_wait4HP FALSE
	/if (${Me.PctHPs} < ${int_myHitpointFloor}) 	/varset bln_wait4HP TRUE
/return


|**
 ----------------------------
 setGroupCommands
 ----------------------------
 Check the group and set the members to singing, or whatever they
 are supposed to be doing. Set the bard to sing and offtank
 ----------------------------
**|
Sub setGroupCommands
	/echo \aoSetGroupCommands
	|-- find a bard and tell them to sing their normal setup (bound to key 2 usually)

	/declare i int local 0
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Class.ShortName.NotEqual[ENC]} && ${Group.Member[${i}].Class.ShortName.NotEqual[WAR]} && ${Group.Member[${i}].Class.ShortName.NotEqual[CLR]} && ${Group.Member[${i}].Class.ShortName.NotEqual[PAL]} && ${Group.Member[${i}].Class.ShortName.NotEqual[SHD]} && ${Group.Member[${i}].Class.ShortName.NotEqual[BRD]}) /varset looter ${Group.Member[${i}].Name}
	/next i

	|-- set the offtank 
	|   if SK is the tank we dont need offtank really.
	/if (${Me.Class.ShortName.NotEqual[SHD]}) {
		/if (${offtank.Equal[NULL]} && ${bln_hasBRD}) {
			/dex ${str_bard} offtankOn
		}
	}
	|-- tell the bard to sing a song
	/if (${bln_hasBRD}) {
		/dex ${str_bard} /memspellset melee
		/delay 10
		/dex ${str_bard} /medley melee
	}  

	|-- find not cleric/tank to loot
	/if (${looter.NotEqual[NOT_FOUND]}) /squelch /dt ${looter} lootOn ALL
	/delay 10
	/varset bln_looting		FALSE

	|-- turn on melee and aggro
	/varset bln_tanking		TRUE
	/varset bln_taunting	TRUE

	|-- set cleric healing to efficient
	/if (${bln_hasCLR}) /dt ${str_cleric} healmode EFFICIENT
	/doevents flush

	|-- make sure tank is not looting
	/varset bln_looting FALSE
/return


|**
 ----------------------------
 UILocked
 ----------------------------
 The UI got locked up. need to fade and remake groups
 ----------------------------  
**|


Sub EVENT_NavStuck
	/echo \arNAVSTUCK Triggered
	/varset bln_navStuck TRUE
	/doevents flush
/return

Sub clearNavStuck
	/if (${bln_navStuck}) {
		/docommand /${cmdChannel} /warp wp camp${int_currentCamp}
		/varset bln_navStuck FALSE
	}
/return

Sub chkGroup
	/if (${Group.GroupSize} == 6) /return
	/echo chkGroup: Group isn't formed
	
	/declare i int local 1
	/for i 1 to 5
		/invite ${groupMember_${i}}
		/delay 1s
	/next i
/return



|**
 ----------------------------
 resetCamp
 ----------------------------
 Before each pull session, tell everyone to go back to the current camp
 ----------------------------
**|

Sub resetCamp
	/docommand /${cmdChannel}	/nav wp camp${int_currentCamp}
/return
		

|**
 ----------------------------
 Initialization
 ----------------------------
 Here we declare variables
 Eventually this needs to be pulled from an INI per zone and per puller!
 ----------------------------
**|
Sub variant_initialize(string _channel, string _announce, string _theme, bool _useDownFlags, bool _highRisk)
	|-- variant specific vars
	/declare inMission 				bool 	outer 	FALSE
	/declare haveMission 			bool 	outer 	FALSE
	/declare ldonType	 			string 	outer 	NOAVAIL
	/declare ldonEntrance 			string 	outer 	unearthed_grave
	/declare bln_useGroup			bool	outer	TRUE
	/declare zoneRequest  			string  outer   ${_theme}
	/declare adventureGiver         string  outer   ${Ini[INI_ldonInfo,${zoneRequest},adventureGiver]}
	/declare zoneMagus         		string  outer   ${Ini[INI_ldonInfo,${zoneRequest},magus]}
	
	/echo \aoInitializing LDON Script (Donor Hall)
	/echo \awLDON Setup \aozoneRequest: \ag${zoneRequest} \aoadventureGiver: \ag${adventureGiver}
	/echo               \aozoneMagus:${zoneMagus}
	
	/declare zoneStart              string  outer   thundercrest
	/declare zoneMission 			string 	outer 	mmcd

	|--camp counts
	/declare int_currentCamp		int		outer	1
	/declare int_campCount			int 	outer	1

	/declare missionComplete        bool	outer	FALSE

	/declare dtIN                   int     outer   9999
	/declare wpIN                   string  outer   notset
	/declare dtOUT					int     outer   9999
	/declare int_xOUT				int		outer 	0
	/declare int_yOUT				int 	outer 	0
	/declare int_zOUT				int		outer	0
	/declare killTarget             string  outer   NULL
	/declare int_killCount 			int 	outer 	0
	/declare int_totalKills			int     outer 	0

	
	|--group members
	/declare bln_hasBST				bool    outer   FALSE
	/declare bln_hasSHM				bool  	outer 	FALSE
	/declare bln_hasBRD				bool  	outer 	FALSE
	/declare bln_hasCLR				bool    outer   FALSE
	/declare str_beastlord			string  outer   NULL	
	/declare str_shaman				string  outer   NULL	
	/declare str_cleric				string  outer   NULL	
	/declare str_bard 				string  outer   NULL		

		/declare bard 					string 	outer NOT_FOUND
	/declare looter 				string 	outer NOT_FOUND
	
	/declare groupMember_0			string	outer  	${Group.Member[0].Name}
	/declare groupMember_1			string	outer  	${Group.Member[1].Name}
	/declare groupMember_2			string	outer  	${Group.Member[2].Name}
	/declare groupMember_3			string	outer  	${Group.Member[3].Name}
	/declare groupMember_4			string	outer  	${Group.Member[4].Name}
	/declare groupMember_5			string	outer  	${Group.Member[5].Name}

	/declare i int local 0
	/for i 0 to 5
		/if (${Group.Member[${i}].Class.ShortName.Equal[SHM]}) {
			/varset bln_hasSHM TRUE
			/varset str_shaman ${Group.Member[${i}].CleanName}
		} else /if (${Group.Member[${i}].Class.ShortName.Equal[BST]}) {
			/varset bln_hasBST TRUE
			/varset str_beastlord ${Group.Member[${i}].CleanName}
		} else /if (${Group.Member[${i}].Class.ShortName.Equal[CLR]}) {
			/varset bln_hasCLR TRUE
			/varset str_cleric ${Group.Member[${i}].CleanName}
		}
	/next i

	|--loot
	/varset bln_looting			FALSE
	/if (${bln_looting}) 		/call EnableLooting
	
	|--offtank
	/declare offtank string	outer   NULL
	/if (${Defined[_offtank]} || ${_offtank.NotEqual[NULL]}) /varset offtank ${_offtank}
	
	|--highrisk?
	/declare bln_highRisk			bool	outer	FALSE	
	/if (${Defined[_highRisk]} || ${_highRisk} != FALSE) /varset bln_highRisk ${_highRisk}
	
	|--melee plugin/aggro for the requester
	/varset bln_tanking TRUE
	
	|--command channel setup
	/if (!${Defined[cmdChannel]}) /declare cmdChannel string	outer	dgga
	/declare cmdChannelExcludingMe string outer dgge
	/varset cmdChannel dgga
	/if (${Defined[_channel]}) /varset cmdChannel ${_channel}
	/echo 	cmdChannel is ${cmdChannel}
	/docommand /${cmdChannel} /speed 1.4
	
	|--announce channel set
	/if (!${Defined[announceChannel]}) /declare announceChannel string	outer	gsay
	/varset announceChannel gsay
	/if (${Defined[_announce]}) /varset announceChannel ${_announce}
	/echo announceChannel is ${announceChannel}


	|--downflags 
	/declare useDownFlags	bool	outer	TRUE
	/if (${Defined[_useDownFlags]} && !${_useDownFlags}) /varset useDownFlags FALSE
	
	|--radii
	/declare int_pcCount			int 	outer   ${SpawnCount[PC]}
	/if (!${Defined[int_campRadius]}) /declare int_campRadius int outer 55
	/varset int_campRadius			55
	/declare int_alert2Radius		int 	outer 	350
	/declare int_campPullRadius		int		outer	350
	/declare int_maxRadius			int		outer	300
	/declare int_minZHeight			int		outer 	-1500
	/declare int_maxPullCount		int     outer   3
	
	|-- use 40 for POFire
	/declare int_maxZHeight			int		outer	4000
	
	|--target information
	/declare int_minTLevel			int		outer	40
	/declare int_maxTLevel			int		outer	75
	/declare bln_validTGT			bool	outer	FALSE
	/declare bln_TGTDead			bool	outer	FALSE
	/declare bln_TGTLocal			bool	outer	FALSE
	/declare int_distTGT			int		outer	0
	/declare int_distTGTPredict		int		outer	0
	/declare int_alertCount			int		outer	0
	
	|--utility floors
	/declare int_myHitpointFloor	int		outer	60
	/declare int_myEnduranceFloor	int		outer	0
	|-- note my mana floor only matters if I am a spell casting puller
	/declare int_myManaFloor		int		outer	20 
	/declare int_clrManaFloor		int		outer	20
	/declare int_encManaFloor		int		outer	0
	/declare bln_wait4Mana			bool	outer	FALSE
	/declare bln_wait4HP			bool	outer	FALSE
	/declare bln_wait4End			bool	outer	FALSE
	
	|--spell & support definitions are declared in xiris_melee.inc
	
	|--set up the camp logic
	/if (!${Defined[D1X]}) /declare D1X 				int outer ${Me.X}
	/if (!${Defined[D1Y]}) /declare D1Y 				int outer ${Me.Y}
	/if (!${Defined[D1Z]}) /declare D1Z 				int outer ${Me.Z}
	
	/declare timer_taunt            timer 	outer    3s

	|--set the puller type 
	/declare strPullType	string	outer	RANGED

	| MELEE DPS CLASS ENUMERATION - Endurance Focus
	/if (${Select[${Me.Class.ShortName},ROG,BER,MNK]}) {
		/varset strPullType RANGED
	}
	
	| MELEE DPS CLASS ENUMERATION - Mana Focus
	/if (${Select[${Me.Class.ShortName},BST,RNG,BRD,PAL]}) {
		/varset strPullType RANGED
	}	
	
	| TANK CLASS ENUMERATION
	/if (${Select[${Me.Class.ShortName},WAR]}) {
		/varset strPullType RANGED
	}		
	
	| TANK CASTER CLASS ENUMERATION
		/if (${Select[${Me.Class.ShortName},SHD]}) {
		/varset strPullType SPELL
	}	

	
	/declare int_obstacleCNT		int 	outer 	0
	/declare bln_noLOS				bool	outer	FALSE	
	/declare bln_tooClose			bool	outer	FALSE
	/declare bln_UILocked			bool 	outer 	FALSE
	/declare bln_navStuck			bool    outer   FALSE

/return





Sub setAlerts
	|=================================
	|--- specific zone mobs to avoid;
	|=================================
	/squelch /alert clear 1
	/squelch /alert add 1 "a bitten victim"
	/squelch /alert add 1 "a petrified colossal tree"
	/squelch /alert add 1 "a hollow tree"
	/squelch /alert add 1 "a trap"
	/squelch /alert add 1 "flavor text"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "six"
	/squelch /alert add 1 "two"
	/squelch /alert add 1 "a hissing"
	/squelch /alert add 1 "four"
	/squelch /alert add 1 "eight"
	/squelch /alert add 1 "three"
	/squelch /alert add 1 "ten"
	/squelch /alert add 1 "aedispellph"
	/squelch /alert add 1 "aerainph"
	/squelch /alert add 1 "from no where"
	/squelch /alert add 1 "mini named controller"
	/squelch /alert add 1 "the hair"
	/squelch /alert add 1 "Keeper of Blood" |note spawns in spot you can't nav to
	/squelch /alert add 1 "a creaking crate"

	|=================================
	|--- specific zone mobs to hunt;
	|=================================
	/squelch /alert clear 2

	|-- LDON Hunter
	| /squelch /alert add 2 "Keeper of Blood" |note spawns in spot you can't nav to
	/squelch /alert add 2 "Yavrin"
	/squelch /alert add 2 "Jerranad"
	
	|-- etc--|
	/squelch /alert add 2 "night watchman"
	/squelch /alert add 2 "officiator"
	/squelch /alert add 2 "Ulyist"
	/squelch /alert add 2 "Keeper of Blood"
	/squelch /alert add 2 "Yavrin"
	/squelch /alert add 2 "Bial the Blade"
	/squelch /alert add 2 "Jerrand"
	/squelch /alert add 2 "Sikl"
	/squelch /alert add 2 "Giddib"
	/squelch /alert add 2 "officiator"
	
	
	
	/squelch /alert clear 3
	/squelch /alert add 3 "All Powerful Gnome"

/return

Sub Event_TooClose
	/echo Event_TooClose
	/varset bln_tooClose TRUE
	/doevents flush TooClose
/return

Sub Event_NoLOS
	/echo Event_NoLOS
	/varset bln_noLOS TRUE
	/doevents flush NoLOS
/return



Sub chkZone
    /declare status string local NORMAL
	/if (${Zone.ShortName.NotEqual[${str_startZone}]}) {
		/if (${Zone.ShortName.Equal[${Me.BoundLocation[0]}]}) {
			/docommand /${announceChannel}  I died! GTFO! ${Time.Time24}
			/delay 5s
			/varset status DEAD
		}
	}
/return ${status}

Sub MoveCamp

/return

Sub setCamp
	/echo Setting camp at camp${int_currentCamp} out of ${int_campCount}

	/varset D1X ${Me.X}
	/varset D1Y ${Me.Y}
	/varset D1Z ${Me.Z}

	/delay 1s
/return


Sub setRSTVars
	/varset	bln_validTGT	FALSE
	/varset bln_TGTDead		TRUE
	/varset bln_TGTLocal	FALSE
	/alert clear 3
	/target clear
/return

Sub setTGTAlert
	/echo setTGTAlert ${Target.ID} ${Target.Name}
	/alert add 3 id ${Target.ID}
	/target clear
/return


Sub EVENT_UILocked
	/varset bln_UILocked TRUE
	/doevents flush
/return

Sub clearUILock
	/if (${bln_UILocked}) {
		/delay 20
		/fade 
		/delay 45s
		/call chkGroup
		/varset bln_UILocked FALSE
	}
/return 